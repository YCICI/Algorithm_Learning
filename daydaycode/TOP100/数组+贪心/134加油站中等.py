# 134. 加油站

# 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

# 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

# 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

 

# 示例 1:

# 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
# 输出: 3
# 解释:
# 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
# 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
# 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
# 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
# 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
# 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
# 因此，3 可为起始索引。
# 示例 2:

# 输入: gas = [2,3,4], cost = [3,4,3]
# 输出: -1
# 解释:
# 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
# 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
# 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
# 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
# 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
# 因此，无论怎样，你都不可能绕环路行驶一周。
 

# 提示:

# gas.length == n
# cost.length == n
# 1 <= n <= 105
# 0 <= gas[i], cost[i] <= 104
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        # # 暴力解法 O(n2) 超出时间限制
        # n = len(gas)
        
        # for i in range(n):
        #     # 以i为起点
        #     have_gas = gas[i]
        #     j = i
        #     # 判断i 为起点是否能 到达下一个点
        #     while have_gas - cost[j] >= 0:
        #         have_gas = have_gas - cost[j] + gas[(j + 1 )%n]
        #         j = (j + 1 )%n
        #         if j == i:
        #             return j

        # return -1
        # 贪心算法 O(n)
        # 维护i为起点的 最远距离 如i最远只能到达 j， 那就以j为起点重新出发
        # 这里不需要看从i+1为起点的情况，i+1如果能到达j+1，i又能到达i+1，那么i一定可以到达哦j+1，这是矛盾的
        # 因此只需要从j出发

        # n = len(gas)
        # i = 0
        # while i < n:
        #     # 以i为起点
        #     have_gas = gas[i]
        #     j = i
        #     # 判断i 为起点是否能 到达下一个点
        #     while have_gas - cost[j] >= 0:
        #         have_gas = have_gas - cost[j] + gas[(j + 1 )%n]
        #         j = (j + 1 )%n
        #         if j == i:
        #             return j
        #     # 能到达的最远距离绕回了i后面直接返回
        #     if j < i:
        #         return -1
        #     # 以j + 1为起点
        #     i = j + 1
        
        # return -1
         ## 贪心算法 继续优化
        # 维护i为起点的 最远距离 如i最远只能到达 j， 那就以j + 1为起点重新出发
        # 这里不需要看从i+1为起点的情况，i+1如果能到达j+1，i又能到达i+1，那么i一定可以到达哦j+1，这是矛盾的
        # 因此只需要从j + 1出发

        n = len(gas)
        star, rest, have = 0, 0, 0
        for i in range(n):
            have += gas[i] - cost[i]
            if have < 0:
                star = i + 1
                have = 0
            # 维护能否走完全程 只要能走完全程 一定有sum(gas) > sum(cost)
            # 原因假设一定能走完全程，一定存在一个起点，假设起点不是0位置，是i位置，那么 “0-i缺的油 一定等于i回到0多的油”
            # 如果不满足 “0-i缺的油 等于i回到0多的油” 那不能走完全程，和假设矛盾，
            # 因此从0开始维护gas - cost 就能判断是否能走完全程
            rest += gas[i] - cost[i]
        
        return star if rest >= 0 else -1
            


